#!/bin/bash

# General purpose devcontainer utility script
# Provides various operations for managing development containers

set -e

# Exit codes
EXIT_SUCCESS=0
EXIT_INVALID_ARGS=1
EXIT_DEP_NOT_FOUND=2
EXIT_DOCKER_ERROR=3
EXIT_DEVCONTAINER_ERROR=4
EXIT_PERMISSION_ERROR=5
EXIT_CONFIG_ERROR=6

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Error handling functions
error_exit() {
    echo -e "${RED}âŒ Error: $1${NC}" >&2
    exit "${2:-$EXIT_INVALID_ARGS}"
}

warning() {
    echo -e "${YELLOW}âš ï¸  Warning: $1${NC}" >&2
}

success() {
    echo -e "${GREEN}âœ… $1${NC}"
}

info() {
    echo -e "${BLUE}â„¹ï¸  $1${NC}"
}

# Input validation functions
validate_command() {
    local cmd="$1"
    local valid_commands="up down restart enter build clean status logs list run init install-agent help completion"
    
    if [[ ! " $valid_commands " =~ $cmd ]]; then
        error_exit "Invalid command '$cmd'. Use 'dcutil help' for available commands." $EXIT_INVALID_ARGS
    fi
}

validate_project_path() {
    local path="$1"
    
    if [ -n "$path" ]; then
        if [ ! -d "$path" ]; then
            error_exit "Project path '$path' does not exist or is not a directory." $EXIT_INVALID_ARGS
        fi
        
        if [ ! -r "$path" ]; then
            error_exit "Cannot read project path '$path'. Permission denied." $EXIT_PERMISSION_ERROR
        fi
        
        # Convert to absolute path
        if ! cd "$path" 2>/dev/null; then
            error_exit "Cannot access project path '$path'." $EXIT_PERMISSION_ERROR
        fi
        PROJECT_DIR="$(pwd)"
        cd - >/dev/null
    fi
}

validate_run_command() {
    if [ $# -eq 0 ]; then
        error_exit "run command requires a command to execute. Usage: dcutil run [project_path] <command>" $EXIT_INVALID_ARGS
    fi
}

validate_init_mode() {
    local mode="$1"
    local valid_modes="fast wizard --fast --wizard --help -h"

    if [ -n "$mode" ] && [[ ! " $valid_modes " =~ $mode ]]; then
        error_exit "Unknown init mode: '$mode'. Use 'dcutil init --help' for usage information." $EXIT_INVALID_ARGS
    fi
}

get_agent_install_command() {
    local agent="$1"

    case "$agent" in
        "opencode")
            echo "curl -fsSL https://opencode.ai/install | bash"
            ;;
        "aider")
            echo "pip install aider-chat"
            ;;
        "copilot-cli")
            echo "npm install -g @github/copilot"
            ;;
        "cody")
            echo "npm install -g @sourcegraph/cody"
            ;;
        "tabnine")
            echo "npm install -g tabnine"
            ;;
        "qwen-cli")
            echo "pip install qwen-cli"
            ;;
        "gemini")
            echo "pip install gemini-cli"
            ;;
        "claude-cli")
            echo "pip install claude-cli"
            ;;
        "openai-cli")
            echo "pip install openai-cli"
            ;;
        *)
            error_exit "Unknown agent '$agent'. Supported agents: opencode, aider, copilot-cli, cody, tabnine, qwen-cli, gemini, claude-cli, openai-cli" $EXIT_INVALID_ARGS
            ;;
    esac
}

# Security hardening functions
verify_checksum() {
    local file="$1"
    local expected_checksum="$2"
    local actual_checksum

    if ! command -v sha256sum &> /dev/null; then
        warning "sha256sum not available, skipping checksum verification"
        return 0
    fi

    actual_checksum=$(sha256sum "$file" | cut -d' ' -f1)
    if [ "$actual_checksum" != "$expected_checksum" ]; then
        error_exit "Checksum verification failed for $file. Expected: $expected_checksum, Got: $actual_checksum" "$EXIT_CONFIG_ERROR"
    fi
    info "Checksum verification passed for $file"
}

check_agent_security_risk() {
    local agent="$1"
    local install_cmd="$2"

    case "$agent" in
        "opencode")
            warning "âš ï¸  HIGH RISK: $agent installation runs remote scripts that could execute arbitrary code."
            echo -e "${YELLOW}Installation command: $install_cmd${NC}"
            read -p "Do you trust the source (opencode.ai) and want to proceed? (yes/no): " -r confirm
            if [[ ! "$confirm" =~ ^[Yy][Ee][Ss]$ ]]; then
                info "Installation cancelled by user"
                exit $EXIT_SUCCESS
            fi
            ;;
    esac
}

secure_download() {
    local url="$1"
    local output_file="$2"
    local expected_checksum="$3"

    info "Downloading $url with security verification..."
    if ! curl -fsSL -o "$output_file" "$url"; then
        error_exit "Failed to download $url" "$EXIT_CONFIG_ERROR"
    fi

    if [ -n "$expected_checksum" ]; then
        verify_checksum "$output_file" "$expected_checksum"
    else
        warning "No checksum provided for $output_file - download integrity not verified"
    fi
}

scan_vulnerabilities() {
    local agent="$1"
    local install_type="$2"
    local venv_dir="$3"

    case "$install_type" in
        "pip")
            info "Running enhanced security scan for Python packages..."

            # Set up environment for portable Python if available
            local pip_cmd="pip"
            local python_cmd="python"
            if [ -n "$venv_dir" ] && [ -f "$venv_dir/bin/python" ]; then
                pip_cmd="$venv_dir/bin/pip"
                python_cmd="$venv_dir/bin/python"
            fi

            # Enhanced vulnerability scanning with multiple tools
            local vulnerabilities_found=false

            # 1. Use safety tool with proper pipenv/venv support
            if devcontainer exec --workspace-folder . /bin/bash -c "$python_cmd -c 'import safety; print(\"safety available\")'" &>/dev/null; then
                info "Running safety vulnerability scan..."
                if ! devcontainer exec --workspace-folder . /bin/bash -c "
                    export PATH=\"$venv_dir/bin:\$PATH\" 2>/dev/null || true
                    $python_cmd -m safety scan --output=text
                " 2>/dev/null; then
                    warning "Safety scan found potential vulnerabilities in $agent"
                    vulnerabilities_found=true
                fi
            else
                info "Installing safety for advanced vulnerability scanning..."
                if devcontainer exec --workspace-folder . /bin/bash -c "
                    $pip_cmd install safety --quiet
                " 2>/dev/null; then
                    info "Running safety vulnerability scan..."
                    if ! devcontainer exec --workspace-folder . /bin/bash -c "
                        export PATH=\"$venv_dir/bin:\$PATH\" 2>/dev/null || true
                        timeout 30 $python_cmd -m safety scan --output=text || $pip_cmd list | grep -E '(aider|opencode|qwen|gemini|claude|openai)' | xargs $pip_cmd show | grep -A5 -B5 'Requires:' | cat
                    " 2>/dev/null; then
                        warning "Safety scan detected potential security issues with $agent dependencies"
                        vulnerabilities_found=true
                    fi
                fi
            fi

            # 2. Check for dependency conflicts using pip-tools/pipdeptree
            info "Checking for package dependency conflicts..."
            if devcontainer exec --workspace-folder . /bin/bash -c "
                $pip_cmd install pipdeptree --quiet 2>/dev/null || true
                if command -v pipdeptree >/dev/null 2>&1; then
                    export PATH=\"$venv_dir/bin:\$PATH\" 2>/dev/null || true
                    pipdeptree --warn fail 2>&1 | grep -q 'conflict\|error' && exit 1 || exit 0
                else
                    $python_cmd -c '
import pkg_resources
import sys
try:
    # Get our installed packages related to the agent
    agent_pkgs = [pkg for pkg in pkg_resources.working_set if any(keyword in pkg.key.lower() for keyword in [\"$agent\", \"assistant\", \"ai\", \"chat\"])]
    if agent_pkgs:
        print(f\"Agent-related packages: {[pkg.key for pkg in agent_pkgs]}\")
    else:
        # Fallback - check all packages
        all_pkgs = list(pkg_resources.working_set)
        if len(all_pkgs) > 50:  # Too many packages, skip conflict check
            print(\"Skipping detailed conflict check - many packages installed\")
        else:
            pkg_dict = {pkg.key: pkg.version for pkg in all_pkgs}
            print(f\"Checked {len(all_pkgs)} packages for conflicts\")
except Exception as e:
    print(f\"Could not check dependencies: {e}\")
    sys.exit(1)
                    '
                fi
            " 2>&1 | grep -q "conflict\|error\|Could not check\|failed"; then
                warning "Potential package conflicts detected for $agent"
                vulnerabilities_found=true
            fi

            # 3. Check for known problematic packages
            info "Checking for packages with known security issues..."
            if devcontainer exec --workspace-folder . /bin/bash -c "
                $pip_cmd list --format=freeze | grep -E '^(pip|setuptools|wheel)=' | while read pkg_line; do
                    pkg_name=\${pkg_line%%=*}
                    pkg_version=\${pkg_line##*=}
                    case \$pkg_name in
                        pip)
                            # Check pip version for security
                            if [[ \"\$pkg_version\" =~ ^([0-9]+)\\. ]]; then
                                major_version=\${BASH_REMATCH[1]}
                                if [ \$major_version -lt 24 ]; then
                                    echo \"WARNING: pip version \$pkg_version is outdated and may have security vulnerabilities\"
                                    exit 1
                                fi
                            fi
                            ;;
                        setuptools)
                            # setuptools has known security issues in old versions
                            if [[ \"\$pkg_version\" =~ ^([0-9]+)\\. ]]; then
                                major_version=\${BASH_REMATCH[1]}
                                if [ \$major_version -lt 65 ]; then
                                    echo \"WARNING: setuptools version \$pkg_version is outdated\"
                                    exit 1
                                fi
                            fi
                            ;;
                    esac
                done || exit 1
            " 2>&1 | grep -q "WARNING"; then
                warning "Outdated or vulnerable core packages detected"
                vulnerabilities_found=true
            fi

            if [ "$vulnerabilities_found" = true ]; then
                warning "âš ï¸  Security scan found issues with $agent dependencies"
                warning "Consider updating packages or choosing a different agent"
            else
                info "âœ… No immediate security issues found for $agent"
            fi
            ;;
        "npm")
            info "Running npm security audit..."
            devcontainer exec --workspace-folder . /bin/bash -c "npm audit --audit-level=high" || warning "npm audit found potential vulnerabilities"
            ;;
    esac
}

# Dependency checking functions
check_devcontainer_cli() {
    if ! command -v devcontainer &> /dev/null; then
        error_exit "devcontainer CLI not found. Please install it first:\n   npm install -g @devcontainers/cli" $EXIT_DEP_NOT_FOUND
    fi
}

check_docker_daemon() {
    if ! docker info &> /dev/null; then
        error_exit "Docker daemon is not running or not accessible. Please start Docker." $EXIT_DOCKER_ERROR
    fi
}

# Determine project directory:
# 1. Use first argument if provided and is a directory
# 2. Use current working directory if it contains .devcontainer
# 3. Use script's directory as fallback
determine_project_dir() {
    local potential_path="$1"
    
    if [ -n "$potential_path" ]; then
        validate_project_path "$potential_path"
    elif [ -f ".devcontainer/devcontainer.json" ] || [ -f ".devcontainer.json" ]; then
        PROJECT_DIR="$(pwd)"
    else
        PROJECT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    fi
    
    # Final validation
    if [ ! -d "$PROJECT_DIR" ]; then
        error_exit "Determined project directory '$PROJECT_DIR' is not valid." $EXIT_CONFIG_ERROR
    fi
}

# Parse and validate arguments
COMMAND="${1:-help}"

# Handle special completion command
if [ "$COMMAND" = "completion" ]; then
    _generate_completion() {
        local shell="${2:-bash}"
        
        if [ "$shell" = "bash" ]; then
            cat << 'BASH_EOF'
#!/bin/bash

# Bash completion for dcutil
_dcutil_completion() {
    local cur prev words cword
    _init_completion || return

    local commands="up down restart enter build clean status logs list run init install-agent help completion"
    local init_commands="fast wizard --fast --wizard --help -h"
    
    case "${prev}" in
        dcutil)
            COMPREPLY=($(compgen -W "${commands}" -- "${cur}"))
            return
            ;;
        init)
            COMPREPLY=($(compgen -W "${init_commands}" -- "${cur}"))
            return
            ;;
        run)
            if [[ ${cword} -eq 2 ]]; then
                local paths=()
                for dir in */; do
                    if [[ -d "${dir}" && ( -f "${dir}.devcontainer/devcontainer.json" || -f "${dir}.devcontainer.json" ) ]]; then
                        paths+=("${dir%/}")
                    fi
                done
                if [[ -f ".devcontainer/devcontainer.json" || -f ".devcontainer.json" ]]; then
                    paths+=(".")
                fi
                paths+=($(compgen -d -- "${cur}"))
                COMPREPLY=($(compgen -W "${paths[*]}" -- "${cur}"))
            else
                local common_commands="bash sh npm node python pip go make cmake cargo rustc"
                COMPREPLY=($(compgen -W "${common_commands}" -- "${cur}"))
            fi
            return
            ;;
        *)
            if [[ "${prev}" != "help" && "${prev}" != "--help" && "${prev}" != "-h" ]]; then
                local paths=()
                for dir in */; do
                    if [[ -d "${dir}" && ( -f "${dir}.devcontainer/devcontainer.json" || -f "${dir}.devcontainer.json" ) ]]; then
                        paths+=("${dir%/}")
                    fi
                done
                if [[ -f ".devcontainer/devcontainer.json" || -f ".devcontainer.json" ]]; then
                    paths+=(".")
                fi
                paths+=($(compgen -d -- "${cur}"))
                COMPREPLY=($(compgen -W "${paths[*]}" -- "${cur}"))
            fi
            return
            ;;
    esac

    if [[ "${cur}" == -* ]]; then
        local options="--help -h"
        COMPREPLY=($(compgen -W "${options}" -- "${cur}"))
        return
    fi
}

complete -F _dcutil_completion dcutil
BASH_EOF
        elif [ "$shell" = "zsh" ]; then
            cat << 'ZSH_EOF'
#compdef dcutil

_dcutil() {
    local -a commands
    commands=(
        'up:Start the devcontainer'
        'down:Stop the devcontainer'
        'restart:Restart the devcontainer'
        'enter:Enter the container shell'
        'build:Build the devcontainer image'
        'clean:Remove the devcontainer and clean up'
        'status:Show container status'
        'logs:Show container logs'
        'list:List running devcontainers'
        'run:Run a command in the container'
        'init:Initialize a devcontainer'
        'install-agent:Install AI agent inside the devcontainer'
        'help:Show help message'
        'completion:Generate completion script'
    )

    local -a init_commands
    init_commands=(
        'fast:Create basic Ubuntu container automatically'
        'wizard:Interactive setup'
        '--fast:Create basic Ubuntu container automatically'
        '--wizard:Interactive setup'
        '--help:Show init help'
        '-h:Show init help'
    )

    local -a common_container_commands
    common_container_commands=(
        'bash:Bash shell'
        'sh:POSIX shell'
        'npm:Node Package Manager'
        'node:Node.js runtime'
        'python:Python interpreter'
        'pip:Python package installer'
        'go:Go compiler'
        'make:Make build tool'
        'cmake:CMake build system'
        'cargo:Rust package manager'
        'rustc:Rust compiler'
    )

    local context state state_descr line
    typeset -A opt_args

    _arguments -C \
        '1: :->command' \
        '*: :->args' \
        && return 0

    case $state in
        command)
            _describe 'command' commands
            ;;
        args)
            case $line[1] in
                init)
                    if [[ $line[2] == --* || $line[2] == -h ]]; then
                        _describe 'init option' init_commands
                    else
                        _describe 'init mode' init_commands
                    fi
                    ;;
                run)
                    if [[ ${#line} -eq 2 ]]; then
                        _alternative \
                            'paths:project path:_directories -S /' \
                            'devcontainer-projects:devcontainer projects:_dcutil_devcontainer_projects'
                    else
                        _describe 'container command' common_container_commands
                    fi
                    ;;
                *)
                    _alternative \
                        'paths:project path:_directories -S /' \
                        'devcontainer-projects:devcontainer projects:_dcutil_devcontainer_projects'
                    ;;
            esac
            ;;
    esac
}

_dcutil_devcontainer_projects() {
    local -a projects
    for dir in */; do
        if [[ -d "$dir" && ( -f "$dir.devcontainer/devcontainer.json" || -f "$dir.devcontainer.json" ) ]]; then
            projects+=("${dir%/}")
        fi
    done
    if [[ -f ".devcontainer/devcontainer.json" || -f ".devcontainer.json" ]]; then
        projects+=(".")
    fi
    _describe 'devcontainer projects' projects
}

_dcutil "$@"
ZSH_EOF
        else
            echo "Supported shells: bash, zsh" >&2
            exit 1
        fi
    }
    
    _generate_completion "$@"
    exit $EXIT_SUCCESS
fi

validate_command "$COMMAND"

# Handle special case for run command (project path can be second arg)
if [ "$COMMAND" = "run" ]; then
    if [ -n "$2" ] && [ -d "$2" ]; then
        determine_project_dir "$2"
        shift 2  # Remove command and project path
    else
        determine_project_dir
        shift 1
    fi
elif [ "$COMMAND" = "install-agent" ]; then
    if [ -n "$2" ] && [ -d "$2" ]; then
        # Second arg is project path, agent is third
        determine_project_dir "$2"
        shift 2
    else
        # Second arg is agent, no project path
        determine_project_dir
        shift 1
    fi
elif [ "$COMMAND" = "init" ]; then
    # For init, second arg is mode, not project path
    determine_project_dir
    shift 1
else
    determine_project_dir "$2"
    shift 1  # Remove command only
fi

# Helper functions
print_usage() {
    echo "Usage: dcutil <command> [project_path] [options]"
    echo ""
    echo "Commands:"
    echo "  up          Start the devcontainer"
    echo "  down        Stop the devcontainer"
    echo "  restart     Restart the devcontainer"
    echo "  enter       Enter the container shell"
    echo "  build       Build the devcontainer image"
    echo "  clean       Remove the devcontainer and clean up"
    echo "  status      Show container status"
    echo "  logs        Show container logs"
    echo "  list        List running devcontainers"
    echo "  run <cmd>   Run a command in the container"
    echo "  init        Initialize a devcontainer (fast or wizard)"
    echo "  install-agent <agent> Install AI agent inside the devcontainer"
    echo "  completion  Generate completion script for bash/zsh"
    echo "  help        Show this help message"
    echo ""
    echo "Project path detection:"
    echo "  - If provided as second argument, uses that directory"
    echo "  - If current directory has .devcontainer/, uses current directory"
    echo "  - Otherwise uses script's directory"
}

# Safe execution functions
safe_devcontainer_command() {
    local cmd="$1"
    shift
    
    if ! check_devcontainer_cli; then
        return $EXIT_DEP_NOT_FOUND
    fi
    
    if ! check_docker_daemon; then
        return $EXIT_DOCKER_ERROR
    fi
    
    if ! devcontainer "$cmd" --workspace-folder "$PROJECT_DIR" "$@" 2>/dev/null; then
        error_exit "Devcontainer command failed: devcontainer $cmd $*" $EXIT_DEVCONTAINER_ERROR
    fi
}

# Change to project directory
info "Using project directory: $PROJECT_DIR"
cd "$PROJECT_DIR" || error_exit "Failed to change to project directory: $PROJECT_DIR" $EXIT_PERMISSION_ERROR

case "$COMMAND" in
    "up")
        info "Starting devcontainer setup..."
        safe_devcontainer_command "up"
        success "Devcontainer started successfully"
        ;;
    
    "down")
        info "Stopping devcontainer..."
        safe_devcontainer_command "down"
        success "Devcontainer stopped"
        ;;
    
    "restart")
        info "Restarting devcontainer..."
        # Stop if running (ignore errors)
        devcontainer down --workspace-folder "$PROJECT_DIR" 2>/dev/null || true
        safe_devcontainer_command "up"
        success "Devcontainer restarted successfully"
        ;;
    
    "enter")
        info "Entering container..."
        check_devcontainer_cli
        check_docker_daemon
        
        # Check if container is running, start it if needed
        if ! devcontainer ps --workspace-folder . 2>/dev/null | grep -q "Running"; then
            warning "Container is not running. Starting it..."
            if ! devcontainer up --workspace-folder . 2>/dev/null; then
                error_exit "Failed to start devcontainer" $EXIT_DEVCONTAINER_ERROR
            fi
        fi
        
        if ! devcontainer exec --workspace-folder . /bin/bash; then
            error_exit "Failed to enter container" $EXIT_DEVCONTAINER_ERROR
        fi
        ;;
    
    "build")
        info "Building devcontainer image..."
        safe_devcontainer_command "build"
        success "Build completed"
        ;;
    
    "clean")
        info "Cleaning up devcontainer..."
        check_devcontainer_cli
        check_docker_daemon
        
        # Stop container first (ignore if not running)
        devcontainer down --workspace-folder . 2>/dev/null || true
        
        # Delete container
        if ! devcontainer delete --workspace-folder . --force 2>/dev/null; then
            warning "Failed to delete devcontainer (may not exist)"
        fi
        success "Cleanup completed"
        ;;
    
    "status")
        info "Checking container status..."
        if devcontainer exec --workspace-folder . echo "Container is running" 2>/dev/null; then
            echo "Container is running"
        else
            echo "Container is not running"
        fi
        ;;
    
    "logs")
        info "Showing container logs..."
        check_docker_daemon
        
        # Get container ID using docker ps with devcontainer label
        CONTAINER_ID=$(docker ps --filter label=devcontainer.local_folder="$PROJECT_DIR" --format "{{.ID}}" 2>/dev/null | head -1)
        if [ -z "$CONTAINER_ID" ]; then
            error_exit "No running devcontainer found for $PROJECT_DIR" $EXIT_DEVCONTAINER_ERROR
        fi
        
        # Show logs
        if ! docker logs "$CONTAINER_ID" 2>/dev/null; then
            error_exit "Failed to show container logs" $EXIT_DEVCONTAINER_ERROR
        fi
        ;;
    
    "list")
        info "Listing running devcontainers..."
        check_docker_daemon
        
        # List containers with devcontainer labels
        if ! docker ps --filter "label=devcontainer.local_folder" --format "table {{.ID}}\t{{.Image}}\t{{.Names}}" 2>/dev/null | grep -v "CONTAINER ID"; then
            echo "No running devcontainers found"
        fi
        ;;
    
    "run")
        validate_run_command "$@"
        info "Running command in container: $*"
        check_devcontainer_cli
        check_docker_daemon
        
        if ! devcontainer exec --workspace-folder "$PROJECT_DIR" "$@"; then
            error_exit "Failed to run command in container" $EXIT_DEVCONTAINER_ERROR
        fi
        ;;
    
    "install-agent")
        if [ $# -eq 0 ]; then
            error_exit "install-agent command requires an agent name. Usage: dcutil install-agent <agent>" $EXIT_INVALID_ARGS
        fi
        AGENT="$1"
        INSTALL_CMD=$(get_agent_install_command "$AGENT")

        info "Installing $AGENT inside devcontainer..."
        check_devcontainer_cli
        check_docker_daemon

        # Check if container is running
        if ! devcontainer exec --workspace-folder . echo "running" 2>/dev/null >/dev/null; then
            warning "Container is not running. Starting it first..."
            if ! devcontainer up --workspace-folder . 2>/dev/null; then
                error_exit "Failed to start devcontainer for $AGENT installation" $EXIT_DEVCONTAINER_ERROR
            fi
        fi

        # Security check for high-risk installations
        check_agent_security_risk "$AGENT" "$INSTALL_CMD"

        info "Installing $AGENT..."

        # Determine install type for vulnerability scanning
        if [[ "$INSTALL_CMD" == npm* ]]; then
            INSTALL_TYPE="npm"
            info "Ensuring npm is available..."
            if ! devcontainer exec --workspace-folder . /bin/bash -c "command -v npm" 2>/dev/null; then
                warning "npm not found. Installing latest Node.js LTS..."
                if ! devcontainer exec --workspace-folder . /bin/bash -c "
                    curl -fsSL https://deb.nodesource.com/setup_lts.x | bash - && apt-get install -y nodejs
                " 2>/dev/null; then
                    error_exit "Failed to install Node.js and npm" $EXIT_DEVCONTAINER_ERROR
                fi
            fi
        elif [[ "$INSTALL_CMD" == pip* ]]; then
            INSTALL_TYPE="pip"
            info "Setting up hermetic Python environment for isolated installation..."
            PYTHON_BIN_DIR="/home/vscode/.dcutil/python"
            VENV_DIR="/home/vscode/.dcutil/agents/$AGENT"

            # Determine platform architecture for portable Python
            PLATFORM=$(devcontainer exec --workspace-folder . /bin/bash -c 'ARCH=$(uname -m); OS=$(uname -s); if [ "$OS" = "Linux" ]; then OS_PREFIX="linux"; elif [ "$OS" = "Darwin" ]; then OS_PREFIX="macos"; else OS_PREFIX="linux"; fi; if [ "$ARCH" = "x86_64" ]; then echo "$OS_PREFIX-x86_64"; elif [ "$ARCH" = "aarch64" ] || [ "$ARCH" = "arm64" ]; then echo "$OS_PREFIX-aarch64"; else echo "linux-x86_64"; fi' 2>/dev/null || echo "linux-x86_64")

            USE_PORTABLE=false
            # Try to set up portable Python
            if devcontainer exec --workspace-folder . /bin/bash -c "PLATFORM=$PLATFORM;
                if [ -x $PYTHON_BIN_DIR/bin/python3 ]; then
                    exit 0
                fi
                mkdir -p $PYTHON_BIN_DIR
                case \$PLATFORM in
                    linux-x86_64) ARCH='x86_64-unknown-linux-gnu' ;;
                    linux-aarch64) ARCH='aarch64-unknown-linux-gnu' ;;
                    macos-x86_64) ARCH='x86_64-apple-darwin' ;;
                    macos-aarch64) ARCH='aarch64-apple-darwin' ;;
                    *) exit 1 ;;
                esac
                LATEST_TAG=\$(curl -s https://api.github.com/repos/astral-sh/python-build-standalone/releases/latest | sed -n 's/.*\"tag_name\": \"\\([^\"]*\\)\".*/\\1/p')
                ASSET_NAME=\$(curl -s https://api.github.com/repos/astral-sh/python-build-standalone/releases/latest | sed -n 's/.*\"name\": \"\\(cpython-3\\.1[23]\\.[0-9]+\\+'\"\$LATEST_TAG\"'-'\"\$ARCH\"'-install_only\\.tar\\.gz\\)\".*/\\1/p' | sort -V | tail -1)
                URL=\"https://github.com/astral-sh/python-build-standalone/releases/download/\$LATEST_TAG/\$ASSET_NAME\"
                if [ -n \"\$ASSET_NAME\" ] && curl -fsSL \"\$URL\" | tar -xz -C $PYTHON_BIN_DIR && [ -x $PYTHON_BIN_DIR/bin/python3 ]; then
                    exit 0
                else
                    exit 1
                fi
            " 2>/dev/null; then
                info "Using hermetic portable Python environment for $AGENT"
                USE_PORTABLE=true
            else
                warning "Failed to set up portable Python, falling back to system Python"
                USE_PORTABLE=false
            fi

            if [ "$USE_PORTABLE" = "true" ]; then
                # Create venv with portable Python
                if ! devcontainer exec --workspace-folder . /bin/bash -c "
                    mkdir -p $VENV_DIR
                    $PYTHON_BIN_DIR/bin/python3 -m venv $VENV_DIR
                " 2>/dev/null; then
                    warning "Failed to create venv with portable Python, falling back to system Python"
                    USE_PORTABLE=false
                fi
            fi

            if [ "$USE_PORTABLE" != "true" ]; then
                # Fallback to system Python virtual environment
                if ! devcontainer exec --workspace-folder . /bin/bash -c "
                    if ! python3 -m venv --help > /dev/null 2>&1; then
                        apt-get update && apt-get install -y python3-venv
                    fi
                    mkdir -p $VENV_DIR
                    python3 -m venv $VENV_DIR
                " 2>/dev/null; then
                    error_exit "Failed to set up system Python venv" $EXIT_DEVCONTAINER_ERROR
                fi
                info "Using system Python environment for $AGENT"
            fi
        elif [[ "$INSTALL_CMD" == curl* ]]; then
            # Special handling for high-risk curl|bash installations
            INSTALL_TYPE="curl"
        else
            INSTALL_TYPE=""
        fi

        # Execute the installation
        if [ "$INSTALL_TYPE" = "pip" ]; then
            INSTALL_CMD="source $VENV_DIR/bin/activate && $INSTALL_CMD"
        fi
        if devcontainer exec --workspace-folder . /bin/bash -c "$INSTALL_CMD" 2>/dev/null; then
            info "Installation completed, running security scans..."

            # Run vulnerability scanning if applicable
            if [ -n "$INSTALL_TYPE" ]; then
                scan_vulnerabilities "$AGENT" "$INSTALL_TYPE" "$VENV_DIR"
            fi

            success "$AGENT installed successfully in devcontainer"
            if [ -n "$VENV_DIR" ] && [ "$USE_PORTABLE" = true ]; then
                info "Hermetic portable Python environment at: $VENV_DIR"
                info "To activate in container: source $VENV_DIR/bin/activate"
                info "To run $AGENT from host: dcutil run 'source $VENV_DIR/bin/activate && $AGENT'"
            elif [ -n "$VENV_DIR" ]; then
                info "Agent is isolated in virtual environment: $VENV_DIR"
                info "To activate in container: source $VENV_DIR/bin/activate"
            fi
        else
            error_exit "Failed to install $AGENT" $EXIT_DEVCONTAINER_ERROR
        fi
        ;;
    
    "init")
        check_devcontainer_cli
        
        # Check if devcontainer already exists
        if [ -f ".devcontainer/devcontainer.json" ] || [ -f ".devcontainer.json" ]; then
            error_exit "Devcontainer configuration already exists. Use 'dcutil clean' first to remove existing configuration" $EXIT_CONFIG_ERROR
        fi
        
        # Parse init options
        INIT_MODE="${1:-wizard}"
        validate_init_mode "$INIT_MODE"
        
        case "$INIT_MODE" in
            "--fast"|"fast")
                info "Creating fast devcontainer configuration..."
                
                # Create .devcontainer directory
                if ! mkdir -p .devcontainer 2>/dev/null; then
                    error_exit "Failed to create .devcontainer directory" $EXIT_PERMISSION_ERROR
                fi
                
                # Create basic devcontainer.json
                if ! cat > .devcontainer/devcontainer.json << 'EOF'
{
    "name": "Basic Dev Container",
    "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
    "customizations": {
        "vscode": {
            "extensions": [
                "ms-vscode.vscode-json"
            ]
        }
    },
    "postCreateCommand": "apt-get update && apt-get install -y curl git"
}
EOF
                then
                    error_exit "Failed to create devcontainer.json file" $EXIT_PERMISSION_ERROR
                fi
                
                success "Fast devcontainer configuration created"
                info "Run 'dcutil up' to start the container"
                ;;
                
            "--wizard"|"wizard"|"")
                info "Devcontainer Initialization Wizard"
                echo ""
                
                # Get project type
                echo -e "${YELLOW}ðŸ“‹ Choose project type:${NC}"
                echo "1) Basic (Ubuntu + common tools)"
                echo "2) Node.js"
                echo "3) Python"
                echo "4) Go"
                echo "5) Custom image"
                echo ""
                read -r -p "Enter choice [1-5]: " project_choice
                
                # Validate project choice
                if [[ ! "$project_choice" =~ ^[1-5]$ ]]; then
                    error_exit "Invalid choice. Please enter a number between 1-5." $EXIT_INVALID_ARGS
                fi
                
                # Get container name
                read -r -p "Container name [My Project]: " container_name
                container_name=${container_name:-"My Project"}
                
                if ! mkdir -p .devcontainer 2>/dev/null; then
                    error_exit "Failed to create .devcontainer directory" $EXIT_PERMISSION_ERROR
                fi
                
                case "$project_choice" in
                    "1")
                        cat > .devcontainer/devcontainer.json << EOF
{
    "name": "$container_name",
    "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
    "customizations": {
        "vscode": {
            "extensions": [
                "ms-vscode.vscode-json",
                "ms-vscode.vscode-git"
            ]
        }
    },
    "postCreateCommand": "apt-get update && apt-get install -y curl git vim nano"
}
EOF
                        ;;
                    "2")
                        cat > .devcontainer/devcontainer.json << EOF
{
    "name": "$container_name",
    "image": "mcr.microsoft.com/devcontainers/javascript-node:18",
    "customizations": {
        "vscode": {
            "extensions": [
                "ms-vscode.vscode-json",
                "esbenp.prettier-vscode"
            ]
        }
    },
    "postCreateCommand": "npm install"
}
EOF
                        ;;
                    "3")
                        cat > .devcontainer/devcontainer.json << EOF
{
    "name": "$container_name",
    "image": "mcr.microsoft.com/devcontainers/python:3.10",
    "customizations": {
        "vscode": {
            "extensions": [
                "ms-python.python",
                "ms-python.vscode-pylance"
            ]
        }
    },
    "postCreateCommand": "pip install -r requirements.txt"
}
EOF
                        ;;
                    "4")
                        cat > .devcontainer/devcontainer.json << EOF
{
    "name": "$container_name",
    "image": "golang:1.21",
    "customizations": {
        "vscode": {
            "extensions": [
                "golang.go"
            ]
        }
    },
    "postCreateCommand": "go mod download"
}
EOF
                        ;;
                    "5")
                        read -r -p "Enter Docker image name: " custom_image
                        if [ -z "$custom_image" ]; then
                            error_exit "Docker image name cannot be empty" $EXIT_INVALID_ARGS
                        fi
                        if ! cat > .devcontainer/devcontainer.json << EOF
{
    "name": "$container_name",
    "image": "$custom_image"
}
EOF
                        then
                            error_exit "Failed to create devcontainer.json file" $EXIT_PERMISSION_ERROR
                        fi
                        ;;
                    *)
                        error_exit "Invalid choice" $EXIT_INVALID_ARGS
                        ;;
                esac
                
                success "Devcontainer configuration created"
                info "Run 'dcutil up' to start the container"
                ;;
                
            "--help"|"-h")
                echo "Usage: dcutil init [mode]"
                echo ""
                echo "Modes:"
                echo "  fast     Create basic Ubuntu container automatically"
                echo "  wizard   Interactive setup (default)"
                echo ""
                echo "Examples:"
                echo "  dcutil init          # Start wizard"
                echo "  dcutil init fast     # Quick basic setup"
                echo "  dcutil init --fast   # Quick basic setup"
                ;;
                
            *)
                echo -e "${RED}âŒ Unknown init mode: $INIT_MODE${NC}"
                echo "Use 'dcutil init --help' for usage information"
                exit 1
            ;;
        esac
        ;;
    "help"|"-h"|"--help")
        print_usage
        ;;
    *)
        error_exit "Unknown command: $COMMAND" $EXIT_INVALID_ARGS
        ;;
esac

exit $EXIT_SUCCESS
